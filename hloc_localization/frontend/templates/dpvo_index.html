<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DPVO Odometry Viewer</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { display: flex; height: 100vh; background: #1e1e1e; color: #e0e0e0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }

  #viewer { flex: 1; border: none; min-width: 0; }

  #side-panel {
    width: 340px; min-width: 280px; max-width: 420px;
    display: flex; flex-direction: column;
    border-left: 1px solid #333;
    background: #252526;
  }
  #panel-header {
    padding: 14px 16px; font-weight: 600; font-size: 15px;
    border-bottom: 1px solid #333; background: #2d2d2d;
    display: flex; justify-content: space-between; align-items: center;
  }
  #mode-badge {
    font-size: 11px; padding: 2px 8px; border-radius: 10px;
    font-weight: 500;
  }
  .mode-hloc { background: #1565c0; color: #bbdefb; }
  .mode-dpvo { background: #e65100; color: #ffe0b2; }
  .mode-idle { background: #333; color: #888; }

  #status-area {
    flex: 1; overflow-y: auto; padding: 16px;
    display: flex; flex-direction: column; gap: 8px;
    font-size: 13px;
  }

  .section-header {
    font-size: 11px; font-weight: 600; text-transform: uppercase;
    color: #666; letter-spacing: 0.5px; margin-top: 8px;
  }

  .stat { color: #aaa; font-size: 12px; padding: 2px 0; }
  .connected { color: #4caf50; }
  .disconnected { color: #f44336; }
  .anchored { color: #4caf50; font-weight: 500; }
  .pending { color: #ff9800; }

  .pose-row { display: flex; justify-content: space-between; padding: 3px 0; }
  .pose-label { color: #888; }
  .pose-value { font-family: 'SF Mono', monospace; color: #4fc3f7; }

  #controls {
    padding: 12px 16px; border-top: 1px solid #333; background: #2d2d2d;
  }
  #controls button {
    width: 100%; padding: 10px; border-radius: 8px; border: none;
    background: #0078d4; color: #fff; font-size: 14px; cursor: pointer;
    font-weight: 500; margin-bottom: 8px;
  }
  #controls button:hover { background: #006bbd; }
  #controls button:disabled { opacity: 0.5; cursor: default; }
  #controls button.stop { background: #d42020; }
  #controls button.stop:hover { background: #b01010; }
  #controls button.secondary { background: #444; }
  #controls button.secondary:hover { background: #555; }

  #ref-select {
    width: 100%; padding: 8px; margin-bottom: 8px;
    background: #1e1e1e; color: #e0e0e0;
    border: 1px solid #444; border-radius: 6px; font-size: 13px;
  }

  .drift-warning {
    display: none; padding: 8px 12px; margin: 4px 0;
    background: #4a3000; border: 1px solid #ff9800;
    border-radius: 6px; font-size: 12px; color: #ffcc02;
  }
  .drift-warning.visible { display: block; }

  #pose-log {
    font-size: 11px; font-family: monospace;
    max-height: 180px; overflow-y: auto; color: #888;
  }
</style>
</head>
<body>

<iframe id="viewer" src="http://localhost:{{ viser_port }}"></iframe>

<div id="side-panel">
  <div id="panel-header">
    DPVO Odometry
    <span id="mode-badge" class="mode-idle">IDLE</span>
  </div>
  <div id="status-area">
    <div class="section-header">Connection</div>
    <div class="stat">Server: <span id="ws-status" class="disconnected">Disconnected</span></div>
    <div class="stat">FPS: <span id="fps-display">--</span></div>
    <div class="stat">Latency: <span id="latency-display">--</span></div>

    <div class="section-header">Anchor</div>
    <div class="stat">Status: <span id="anchor-status" class="pending">Not localized</span></div>
    <div class="stat">Inliers: <span id="anchor-inliers">--</span></div>

    <div class="section-header">Odometry</div>
    <div class="stat">Pose count: <span id="pose-count">0</span></div>
    <div class="stat">Source: <span id="pose-source">--</span></div>

    <div class="drift-warning" id="drift-warning">
      Long session detected. Poses may drift from world coordinates.
      Consider re-anchoring.
    </div>

    <div class="section-header">Current Pose</div>
    <div class="pose-row"><span class="pose-label">tx</span><span class="pose-value" id="tx">--</span></div>
    <div class="pose-row"><span class="pose-label">ty</span><span class="pose-value" id="ty">--</span></div>
    <div class="pose-row"><span class="pose-label">tz</span><span class="pose-value" id="tz">--</span></div>
    <div class="pose-row"><span class="pose-label">qw</span><span class="pose-value" id="qw">--</span></div>
    <div class="pose-row"><span class="pose-label">qx</span><span class="pose-value" id="qx">--</span></div>
    <div class="pose-row"><span class="pose-label">qy</span><span class="pose-value" id="qy">--</span></div>
    <div class="pose-row"><span class="pose-label">qz</span><span class="pose-value" id="qz">--</span></div>

    <hr style="border-color: #333; margin: 8px 0;">
    <div id="pose-log"></div>
  </div>
  <div id="controls">
    <select id="ref-select"><option value="">Loading references...</option></select>
    <button id="start-btn" onclick="startStream()">Start Streaming</button>
    <button id="stop-btn" class="stop" onclick="stopStream()" disabled>Stop</button>
    <button class="secondary" onclick="loadReferences()">Refresh References</button>
  </div>
</div>

<script>
const API = `${location.protocol}//${location.host}`;
let ws = null;
let streaming = false;
let frameCount = 0;
let lastFpsTime = Date.now();
let poseCount = 0;
let anchorLocalized = false;
let sessionStart = null;

async function loadReferences() {
  try {
    const resp = await fetch(`${API}/api/reference/status`);
    const data = await resp.json();
    const sel = document.getElementById('ref-select');
    sel.innerHTML = '';
    if (!data.available || data.available.length === 0) {
      sel.innerHTML = '<option value="">No references available</option>';
      return;
    }
    data.available.forEach(r => {
      const opt = document.createElement('option');
      opt.value = r.name;
      opt.textContent = `${r.name} (${r.size_mb.toFixed(1)} MB)`;
      if (r.active) opt.selected = true;
      sel.appendChild(opt);
    });
  } catch (e) {
    console.error('Failed to load references:', e);
  }
}
loadReferences();

function startStream() {
  const ref = document.getElementById('ref-select').value;
  if (!ref) { alert('Select a reference first'); return; }

  // Select reference
  fetch(`${API}/api/reference/select/${ref}`, { method: 'POST' });

  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${proto}://${location.host}/ws/localize`);

  ws.onopen = () => {
    document.getElementById('ws-status').textContent = 'Connected';
    document.getElementById('ws-status').className = 'connected';
    streaming = true;
    anchorLocalized = false;
    poseCount = 0;
    sessionStart = Date.now();
    document.getElementById('start-btn').disabled = true;
    document.getElementById('stop-btn').disabled = false;
    setMode('hloc');
    startCapture();
  };

  ws.onmessage = (e) => {
    const pose = JSON.parse(e.data);
    updateDisplay(pose);
  };

  ws.onclose = () => {
    document.getElementById('ws-status').textContent = 'Disconnected';
    document.getElementById('ws-status').className = 'disconnected';
    streaming = false;
    document.getElementById('start-btn').disabled = false;
    document.getElementById('stop-btn').disabled = true;
    setMode('idle');
  };
}

function stopStream() {
  streaming = false;
  if (ws) ws.close();
}

function setMode(mode) {
  const badge = document.getElementById('mode-badge');
  badge.textContent = mode.toUpperCase();
  badge.className = `mode-${mode}`;
}

let videoEl = null;
let canvasEl = null;

async function startCapture() {
  if (!videoEl) {
    videoEl = document.createElement('video');
    videoEl.autoplay = true;
    canvasEl = document.createElement('canvas');
  }
  const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
  videoEl.srcObject = stream;
  await videoEl.play();
  canvasEl.width = videoEl.videoWidth;
  canvasEl.height = videoEl.videoHeight;
  sendFrame();
}

function sendFrame() {
  if (!streaming || !ws || ws.readyState !== WebSocket.OPEN) return;

  const ctx = canvasEl.getContext('2d');
  ctx.drawImage(videoEl, 0, 0);
  canvasEl.toBlob((blob) => {
    if (blob && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(blob);
      frameCount++;
      const now = Date.now();
      if (now - lastFpsTime > 1000) {
        document.getElementById('fps-display').textContent = frameCount.toFixed(1);
        frameCount = 0;
        lastFpsTime = now;
      }
    }
  }, 'image/jpeg', 0.85);
}

function updateDisplay(pose) {
  if (pose.success) {
    poseCount++;
    document.getElementById('pose-count').textContent = poseCount;

    ['tx', 'ty', 'tz', 'qw', 'qx', 'qy', 'qz'].forEach(k => {
      document.getElementById(k).textContent = pose[k].toFixed(4);
    });

    const source = pose.source || 'hloc';
    document.getElementById('pose-source').textContent = source;

    if (!anchorLocalized) {
      anchorLocalized = true;
      document.getElementById('anchor-status').textContent = 'Localized';
      document.getElementById('anchor-status').className = 'anchored';
      document.getElementById('anchor-inliers').textContent = pose.num_inliers || '--';
      setMode('dpvo');
    }

    if (pose.latency_ms) {
      document.getElementById('latency-display').textContent = `${pose.latency_ms.toFixed(0)}ms`;
    }

    // Drift warning after 5 minutes
    if (sessionStart && (Date.now() - sessionStart) > 300000) {
      document.getElementById('drift-warning').classList.add('visible');
    }

    const log = document.getElementById('pose-log');
    const line = `[${source}] t=(${pose.tx.toFixed(2)}, ${pose.ty.toFixed(2)}, ${pose.tz.toFixed(2)})\n`;
    log.textContent += line;
    log.scrollTop = log.scrollHeight;
  } else {
    document.getElementById('pose-source').textContent = 'FAIL';
    const log = document.getElementById('pose-log');
    log.textContent += `FAIL: ${pose.error || 'unknown'}\n`;
    log.scrollTop = log.scrollHeight;
  }

  // Request next frame after receiving pose
  if (streaming) setTimeout(sendFrame, 50);
}
</script>
</body>
</html>
